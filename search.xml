<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Blog&amp;Hexo</title>
      <link href="/2020/03/06/blog/"/>
      <url>/2020/03/06/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="如何创建一个属于自己的Blog网站"><a href="#如何创建一个属于自己的Blog网站" class="headerlink" title="如何创建一个属于自己的Blog网站"></a>如何创建一个属于自己的</font><font color=#8A2BE2>Blog</font>网站</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p><b><font color=#4682B4>(●’◡`●) 几乎每个码农都有一个属于自己的 Blog 这貌似成为了一种不成文的习惯,所以我做了这篇搭建个人博客的教程,说到Blog,我更倾心于 GitHub Page 方式的个人静态博客，虽然每次需要自己基于 Markdown 文档生成HTML页面，但是这种方式一是<font color=red>免费</font>，二是可以完全自定义博客且木有<font color=red>广告链接</font>，想用起来极为<font color=red>干净舒适！</font>三是已经极大的<font color=red>简化前端代码的编写</font>,当然你也可以对其进行修改,这需要你对<font color=#0000FF> HTML CSS JSP </font>等一些前端知识的语法的了解——(这些语法百度都可以查的到的)<br>如果你不了解,你也可以尝试,做一个属于自己的博客网站,学习一些语法进行修改—-搭建个人觉得教程难度不高,我会尽量说明详细<br>PS:原生创建的方式可能过于繁琐，目前有插件支持直接在浏览器编写，有的网站可以做到实时编写</font></b></p><p><img src="/img/Text_Bg_img/ScreenShot/github.jfif" alt="Github"></p><p><a href="https://github.com/join?source=login" target="_blank" rel="noopener">Gayhub</a> 直达地址–世界上最大的同性交友平台(男性占有95%,女性占有3%,未表明性别2%),提供Pages服务,同时也是很多大神的聚集地,如果你的项目很受关注就会有很多大神无偿帮你修改代码和增加功能,甚至能收到一些公司的 office (〃￣︶￣)人(￣︶￣〃)<br></p><p><img src="/img/Text_Bg_img/ScreenShot/gitee.png" alt="Gitee"></p><p><a href="https://www.zhihu.com/question/50212423" target="_blank" rel="noopener">码云</a> 一个国内的代码托管平台,可以说是国内版的Github,也提供Pages 服务 ,同时提供Github 代码克隆,不过和github 不一样的地方是自定义域名需要收费(免费提供一个月的服务)</p><ul><li>两种选择–都会分配 <a href="https://baike.baidu.com/item/%E5%AD%90%E5%9F%9F%E5%90%8D/10937658?fr=aladdin" target="_blank" rel="noopener">子域名</a> ,总的来说,有好也有坏 ヽ(￣ω￣(￣ω￣〃)ゝ<br>Github (无收费,除了私有仓库收费,还有国内一些人访问可能无法访问.有没有方法可以拯救,有 <a href="https://baike.baidu.com/item/CDN/420951?fr=aladdin" target="_blank" rel="noopener">CDN</a> 加速访问 成本高 (不推荐))<br>Gitee (私有仓库不收费,但是pages一年服务 99软妹币,但是国内访问速度快),如果你不在意自定义域名(推荐)<br>根据情况自行选择 想要完美的方法<font color=#DC1455> 加钱 加钱 加钱</font></li></ul><h2 id="需要下载的工具"><a href="#需要下载的工具" class="headerlink" title="需要下载的工具"></a><font size=6 color=#DC143C>需要下载的工具</font></h2><p>接下来就是开始下载创建博客的工具  我们会用到几个需要的软件</p><h3 id="Git-一个-开源-的分布式版本控制系统"><a href="#Git-一个-开源-的分布式版本控制系统" class="headerlink" title="Git  一个 开源 的分布式版本控制系统"></a><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>  一个<b> 开源 </b>的分布式版本控制系统</h3><p><img src="/img/Text_Bg_img/ScreenShot/git.jpg" alt="Git"><br>Git这只是个版本管理工具,Github就是建立在Git上的一个网站(一个用于让程序员交流的平台),这是两个不同的东西<br>Git “创始人” 是 <a href="https://dwz.cn/Vx5HbttD" target="_blank" rel="noopener">Linus Torvalds</a> 也是Linux系统之父 他为了帮助并管理 Linux 内核的开发而开发的的一个开放源代码的版本控制软件<br><br></p><h3 id="Hexo-成立于-2012年-这是一个快速帮助你搭建网站的的-框架"><a href="#Hexo-成立于-2012年-这是一个快速帮助你搭建网站的的-框架" class="headerlink" title="Hexo 成立于 2012年 这是一个快速帮助你搭建网站的的 框架"></a><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 成立于 2012年 这是一个快速帮助你搭建网站的的 <a href="https://dwz.cn/RYTLEByn" target="_blank" rel="noopener">框架</a></h3><p><img src="/img/Text_Bg_img/ScreenShot/Hexo.jpg" alt="Hexo"><br><br></p><h3 id="Node-Js-一个基于Chrome-v8-引擎的JavaScript-的运行环境"><a href="#Node-Js-一个基于Chrome-v8-引擎的JavaScript-的运行环境" class="headerlink" title="Node-Js 一个基于Chrome v8 引擎的JavaScript 的运行环境"></a><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node-Js</a> 一个基于Chrome v8 引擎的JavaScript 的运行环境</h3><p><img src="/img/Text_Bg_img/ScreenShot/Node.jpg" alt="Node.JS"><br><br></p><h2 id="Github-Gitee–教程-大同小异"><a href="#Github-Gitee–教程-大同小异" class="headerlink" title="Github/Gitee–教程(大同小异)"></a><font size=6 color=#FF69B4>Github/Gitee–教程(大同小异)</font><br></h2><p>我会尽量详细说明每一步骤 其中有些可以<font color=red>跳过</font> (～￣▽￣)～<br>第一步 (不知道网址的可以回到顶部前言,可以直接点击跳转或者通过各大搜索引擎进行搜索)<br>创建账号<font color=#191970>(二选一)</font> </p><ul><li><p><img src="/img/Text_Bg_img/ScreenShot/github/CreateGithubUser.png" alt="Github-reg"></p></li><li><p><img src="/img/Text_Bg_img/ScreenShot/gitee/regGitee.png" alt="Gitee-reg"></p></li><li><p><font color=red>登录</font>注册的账户,然后创建一个属于自己的仓库 ( 两个网站都是同样的操作  二选一)</p><p>  PS:如果我的用户名名叫Gsiiiii 创建的仓库名就是 Gsiiiii.github.io —–Github 要严格遵守这个规则<br>  Github<br>  <img src="/img/Text_Bg_img/ScreenShot/github/create0.png" alt="Github_create"></p><p>  码云<br>  <img src="/img/Text_Bg_img/ScreenShot/gitee/gitee_reg.png" alt="Gitee_create"></p></li></ul><h3 id="开启-Pages-服务"><a href="#开启-Pages-服务" class="headerlink" title="开启 Pages 服务"></a>开启 Pages 服务</h3><p><img src="/img/Text_Bg_img/ScreenShot/github/github_Pages.png" alt="Github_pages"></p><p><img src="/img/Text_Bg_img/ScreenShot/gitee/create_Pages.png" alt="Gitee_Pages_1"></p><p><img src="/img/Text_Bg_img/ScreenShot/gitee/Pages.png" alt="Gitee_Pages_2"></p><h2 id="请检查-Git和Node-js-是否安装成功"><a href="#请检查-Git和Node-js-是否安装成功" class="headerlink" title="请检查 Git和Node.js 是否安装成功"></a>请检查 Git和Node.js 是否安装成功</h2></h2><h4>win+R 组合键 -> 输入cmd回车打开终端 , 输入</h4><pre><code class="MD">git -version</code></pre><pre><code class="MD">node -v</code></pre><h4>出现版本号就说明成功或者返回一些操作说明也算成功</h4><h3 id="获取SSH-将Git和github-gitee关联起来-非必须-这一步可以不做-做了方便部署"><a href="#获取SSH-将Git和github-gitee关联起来-非必须-这一步可以不做-做了方便部署" class="headerlink" title="获取SSH(将Git和github/gitee关联起来) (非必须)这一步可以不做,做了方便部署"></a>获取SSH(将Git和github/gitee关联起来) (非必须)这一步可以不做,做了方便部署</h3><p>打开Git 当 Git安装完成的时候,在桌面和任意文件中鼠标 <b>右击</b> 都会出现<br><b>Git GUI Here</b> 和 <b>Git Bash Here</b> 两个选项<br>我们选择下面的 <b>Git Bash Here</b></p><pre><code class="MD">    $ ssh-keygen -t rsa</code></pre><p>生成的密钥存放地址<br>(注意:这是个隐藏文件夹 点开头的文件夹都是默认隐藏的,你可以直接复制地址复制到任意文件夹路径可直接访问,或者打开显示隐藏文件夹的设置,自己按路径进行查找)<br><img src="/img/Text_Bg_img/ScreenShot/case/ssh.jpg" alt="示例">    </p><pre><code class="MD">/* * 将id_rsa.pub文件里的内容复制,在github 上进行绑定  * github 页面右上角头像旁下拉选-&gt;Settings(设置) * 页面的左侧有一选项 SSH and GPG keys -&gt; New SSH Key -&gt; 起个标题自己能分辨就行 把复制的内容放在Key中 * Add SSH Key */</code></pre><h3 id="SSH连接测试"><a href="#SSH连接测试" class="headerlink" title="SSH连接测试"></a>SSH连接测试</h3><pre><code class="MD">$ ssh -T git@github.com// 如果看到Hi后面是你的用户名，就说明成功了 else 失败 </code></pre><h3 id="Hexo的安装与基本命令"><a href="#Hexo的安装与基本命令" class="headerlink" title="Hexo的安装与基本命令"></a><font color=red>Hexo的安装与基本命令</font></h3><p>接下来我们可以安装生成网站的关键——Hexo架构了，其主要信息和安装命令、主题等都可以从其官网轻松得到：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>在桌面新建一个文件夹 ,命名无所谓(你记得就行), 进入 文件夹 右击点击 选择 Git Bash Here<br>输入<font color=red>以下命令</font> 就是Hexo官网首页的哪一行命令行</p><pre><code class="MD">npm install hexo-cli -g </code></pre><h3 id="等待hexo-安装-此步骤可能会花点时间-服务器在国外-解决方案就是挂代理"><a href="#等待hexo-安装-此步骤可能会花点时间-服务器在国外-解决方案就是挂代理" class="headerlink" title="等待hexo 安装 (此步骤可能会花点时间,服务器在国外,解决方案就是挂代理)"></a>等待hexo 安装 (此步骤可能会花点时间,服务器在国外,解决方案就是挂代理)</h3><p>测试</p><pre><code class="MD">git 输入hexo -v，检查hexo 出现版本号成功 else 失败 </code></pre><p>github/gitee :<br>在<font color=red>Git Bash Here </font>中输入</p><pre><code class="MD">    gitee: hexo init 进行初始化    github: hexo init 加上你的仓库名  进行初始化    &lt;--举例: 如果我的仓库名叫Gsiiiii 那么写法就是 Gsiiiii.github.io--&gt;</code></pre><p>等待创建(hexo 会从云端下载)<br>等待hexo 安装 (此步骤可能也会花点时间,服务器在国外,解决方案就是挂代理)<br>然后就可以使用Hexo三连了，<font color=red>即我们最常用的三个主要命令</font>（依旧在上述Git Bash命令端口中）：</p><pre><code class="MD">    hexo clean # 清空已有hexo网站文件    hexo generate(or g) # 依据网页文本与新的CSS样式生成新网站文件    hexo server(or s) # 启动本地服务器，可以在localhost:4000查看网站修改效果</code></pre><p>依次运行上述三个命令，就可以在浏览器输入<font color=red>localhost:4000</font> 查看对应网站界面效果，一般默认的是一个landscape主题，后期当提交新文章或者新的样式修改时，往往都是先从本地查看结果无误后再部署到Gitee Page。</p><h3 id="主题下载与安装-主题地址"><a href="#主题下载与安装-主题地址" class="headerlink" title="主题下载与安装  主题地址"></a>主题下载与安装  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题地址</a></h3><p><img src="/img/Text_Bg_img/ScreenShot/case/theme.png" alt="Theme"></p><p>Hexo官网上提供了丰富的主题可选，你只需要打开对应的界面 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 选择喜欢的，然后点击名称跳转到GitHub仓库选择下载或者克隆对应的zip文件到本地，并且解压到网站目录下的<font size=5 color=red>themes目录下!!!!!!!!</font><br>如何下载?<br>    主题作者github 网页README 执行 install(有的不是,看图) 哪一行代码就会下载<br>    <img src="/img/Text_Bg_img/ScreenShot/case/use_theme.png" alt="Hexo_Theme"></p><p>等待下载<br>下载完成去配置主题信息<br>打开根文件夹中的_config.yml 配置文件 (可以使用记事本进行修改或者其他工具)<br><img src="/img/Text_Bg_img/ScreenShot/case/config.png" alt="config"></p><p><font color=red>最重要</font>的是修改使用的主题: </p><pre><code class="yml">theme: diaspora-----&gt;(你使用的主题文件名)</code></pre><p>其他属性的修改</p><pre><code class="yml">title: GuSu-Blog -------&gt;(浏览器页面显示的标题)author: Gs --------(作者-写你自己的名字/昵称)language: en -------&gt;(语言)timezone: Asia/Shanghai------&gt;(时间/这里我设置的是 亚洲/上海)url: gusu.xyz---------&gt;(这里修改为返回主页面的连接/自己的域名或者github 分配的子域名)</code></pre><p><font size=5 color=red>Gitee坑一:</font> gitee创建方式这里有个<font color=red>大坑</font> 会导致新建仓库与Gitee不同名导致无法正确解析 github默认就行<br>网站配置文件采用文本样式打开后，可以找到下面一段代码：</p><pre><code class="yml"># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://muqianzhi.gitee.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:</code></pre><p>上述说明中提到可以自定义名称，只需要在root字段修改即可，然而这里有两个容易出问题的地方：<br>你的URL并不是你所在仓库的地址，而应该是你启动仓库的Gitee Page服务后分配给你的网站 <font color=red>静态域名</font>，以我个人为例，仓库地址为：<a href="https://gitee.com/Gusucloud/Gs" target="_blank" rel="noopener">https://gitee.com/Gusucloud/Gs</a> 而这里应该写网站URL应为“服务–Gitee Page”启动/更新后显示分配的网站地址<br>你的网站目录当然可以和账户不同名，但是那样就需要按照文档说明修改root字段，自己当初定义的名称不同，结果导致域名莫名无法解析，总是无法正确访问网页，因此干脆像GitHub Page一样强制要求使用账号同名新建网站仓库，这样还获得了以账号名为特征的独有域名，一举两得！ <font>如果你自定义的仓库 root: /仓库名/ 需要改成这样</font><br><font size=5 color=red>Gitee坑二:</font>  Git部署目录不是仓库地址！<br>修改代码：</p><pre><code class="yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepository: https://gitee.com/Gusucloud/Gs.gitbranch: master</code></pre><p>Ps: 上面的repository地址并不是仓库的地址，而是你下载/克隆项目时弹出的那个地址，如果使用git就选择SSH，如果选择HTTPS那么相应的type字段也要修改为https<br><img src="/img/Text_Bg_img/ScreenShot/case/git.png" alt="git"></p><p>完成上述修改后，一般而言可以启动本地服务器（你还记得上面的 hexo s 么？），然后从localhost:4000访问查看即可。<br>后面就比较简单了，你需要仔细阅读主题文件下的README.md文件以根据主题特点实现自定制网站。在此之前，你还需要在网站的Git Bash中运行一次安装所有主题依赖插件包的命令：</p><pre><code class="MD">$ npm install</code></pre><p>Gitee端的更新<br>这个问题在github 上不需要做的会自动部署,发现这个问题还是我把github 的博客克隆到码云上发现我提交我的我的项目时,但页面一直不会变,,,,,,,查了半天原因在于: 你没有点更新…..淦 ┑(￣Д ￣)┍<br>在转移的过程中发生了不少问题,CSS样式,图片啥的全没了,,,(发现的问题我上面都提到了)</p><h3 id="主题-amp-图片-进行修改-替换"><a href="#主题-amp-图片-进行修改-替换" class="headerlink" title="主题&amp;图片 进行修改/替换"></a><b>主题&amp;图片</b> 进行修改/替换</h3><p>(默认情况下,主题内容里很多信息的内容例如:Github 的地址和一些其他链接填写的是主题制作人本身的,所以需要 你自己进行修改)<br>themes 文件夹是你主题的文件夹<br>进入文件夹,打开里面的_config.yml 文本文件<br>你可以在这个文本中修改,背景音乐 ,封面图……..等待自己发现哦 ο(=•ω＜=)ρ⌒☆<br>有些作者也会写一份对应的文档在主题包里<br>配置完执行 </p><pre><code class="MD">[hexo clean] -&gt; [hexo g] -&gt; [hexo s] </code></pre><p>会提示系统端口 4000 复制进浏览器进入查看<br>可以根据你的需要对生成的html 文件进行修改,这需要你对HTML 语法稍微的掌握以及对CSS 语法的也有稍微的了解</p><p><font color=red>官网还有很多插件等你发现</font></p><h2 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h2><p>上述过程记录了一般采用Gitee/Github+Hexo搭建个人博客的过程，除了跳过几个“坑”之外，还需要认真阅读主题目录下的README.md文件，以进一步修改页面的索引、标签、图片风格等具体样式。<br>好了，到此为止，你已经有了一个初步的个人博客，剩下的是根据需要添加不同插件或者调整风格了。<br>φ(゜▽゜*)♪</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机发展简史</title>
      <link href="/2020/03/04/Computer/"/>
      <url>/2020/03/04/Computer/</url>
      
        <content type="html"><![CDATA[<p><font color=#87CEFA>目前计算机对人类的生活来说可以说是密不可分了<br>上网购物，银行转账，网络通信等都有计算机来控制，如果哪一天没有计算机，我们的生活真是不敢想象。计算机从开始到现在已有五、六十年的发展，可以说发展是相等的迅猛，让我们看看计算机的<font color=#9370DB>发展简史</font>吧。</font></p><p>1924年，<a href="https://www.ibm.com/cn-zh" target="_blank" rel="noopener">IBM</a> 一个有划时代意义的公司成立了。</p><p>1936年，美国青年 <a href="https://dwz.cn/ki3peypu" target="_blank" rel="noopener">霍德华·艾肯</a> 去哈佛共度物理学博士学位，由于博士论文设计设计空间电荷传导理论，需要计算非常复杂的非线性微分方程。艾肯想发明一种机器代替人工计算，幻想有一台计算机帮他解决数学难题。三年后，艾肯在图书馆里发现了巴贝奇和阿达的论文。 博士毕业后，艾肯进入了美国海军军械局做了一名小小的海军中尉。为了实现计算机的梦想，他想到了 IBM。正好艾肯的一位老师正在IBM出资创办的“哥伦比亚大学统计局”里任职，艾肯从这位老师这里听说了IBM董事长<a href="https://dwz.cn/IhUiendA" target="_blank" rel="noopener">沃森</a>的大名。这位老师为艾肯写了一封推荐信。艾肯拿到推荐信后，准备好了一份可行性报告，就去找沃森。沃森听完了艾肯的话以后，直接给艾肯划了100W美元。有了钱，艾肯开始了“<a href="https://dwz.cn/QYFIQa7a" target="_blank" rel="noopener">MARK I</a>”（马克1号）的研发。马克1号借助电流进行运算，最关键的部件采用继电器组成，马克1号上安装了大约3000个继电器。继电器接通电路表示“1”，继电器断开则表示“0”。继电器能在大约1/100秒内接通或断开电路。</p><p><font color=red>BUG的由来</font>–为马克1号编制计算程序的也是一位女数学家<a href="https://dwz.cn/jyxzBIij" target="_blank" rel="noopener">格雷斯·霍波</a>（G.Hopper）。有一天，她在调试程序时出现了故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍波恢谐地把程序故障统称为“臭虫”（bug，现在表示电脑系统或程序中的一些缺陷或问题）</p><p>1944年2月，马克1号计算机在哈佛大学正式运行。从外表看，它的外壳用钢和玻璃制成，长约15米，高约2.4米，自重达到31.5吨，他可以每分钟进行200次以上的运算。可以作23位数加23位数的加法，一次仅需要0.3秒；而进行同样位数的乘法，则需要6秒多的时间。<br>马克1号被称为最后一台“史前”计算机——机械/电动方式。</p><h2 id="世界上第一台计算机-美国-电子管计算机（1946年-1957年）"><a href="#世界上第一台计算机-美国-电子管计算机（1946年-1957年）" class="headerlink" title="世界上第一台计算机(美国) 电子管计算机（1946年-1957年）"></a>世界上第一台计算机(美国) 电子管计算机（1946年-1957年）</h2><p>它的名字叫 <a href="https://baike.baidu.com/item/ENIAC/431133?fr=aladdin" target="_blank" rel="noopener">ENIAC</a> (Electronic Numerical Integrator and Computer)<br>是美国人莫克利（JohnW.Mauchly）和艾克特（J.PresperEckert）发明的，主要是有大量的电子管组成，主要用于科学计算，当时美国国防部用它来进行弹道计算。<br>研制单位: <a href="https://dwz.cn/cRuppr1B" target="_blank" rel="noopener">美国宾夕法尼亚大学</a><br><img src="https://bkimg.cdn.bcebos.com/pic/242dd42a2834349bd386df3ec9ea15ce37d3be8d?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5" alt="Eniac"></p><p><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_3.jpeg" alt="冯.诺依曼与第一代计算机"></p><p>当时的性能 每秒5000次运算，每秒50次的乘法运算，能计算平方和立方计算，Sin和Coc 函数数值运算和一些其他的复杂运算<br>体积价格: 它包含了17,468根真空管（电子管）7,200根晶体二极管，1,500 个中转，70,000个电阻器，10,000个电容器，1500个继电器，6000多个开关。，170 平方米，大约两间房子大,30吨,功耗约150千瓦,耗费48万美金<br><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_2.jpeg" alt="电子管"></p><p>缺点:<br>    由于它使用的电子管体积很大，耗电量大，易发热，因而工作的时间不能太长。造价金额高<br>    使用机器语言，没有系统软件。<br>    采用磁鼓、小磁芯作为储存器，存储空间有限。<br>    采用磁鼓、小磁芯作为储存器，存储空间有限。</p><h2 id="第二代计算机-1958-1964年-晶体管"><a href="#第二代计算机-1958-1964年-晶体管" class="headerlink" title="第二代计算机(1958-1964年) 晶体管"></a>第二代计算机(1958-1964年) 晶体管</h2><p><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_4.jpeg" alt="第二代计算机"></p><p>第二代计算机采用的主要元件是晶体管，称为晶体管计算机。其内存存储器由磁芯构成，磁鼓与磁带称为外存储器，逻辑结构实现了浮点运算，并提出了变址,中断,I/O处理等新概念<br><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_5.jpeg" alt="晶体管"></p><p>计算机软件有了较大发展，晶体管代替了体积庞大电子管，使用磁芯存储器。体积小、速度快、功耗低、性能更稳定。还有现代计算机的一些部件:打印机、磁带、磁盘、内存、操作系统等。在这一时期出现了更高级的COBOL和FORTRAN等编程语言，使计算机编程更容易。新的职业(程序员、分析员和计算机系统专家)和整个软件产业由此诞生。</p><h2 id="第三代计算机-中小规模集成电路计算机-60年代中到70年代中期"><a href="#第三代计算机-中小规模集成电路计算机-60年代中到70年代中期" class="headerlink" title="第三代计算机 中小规模集成电路计算机(60年代中到70年代中期)"></a>第三代计算机 中小规模集成电路计算机(60年代中到70年代中期)</h2><p><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_6.jpeg" alt="第三代计算机-IBM 360"></p><p>集成电路可在几平方毫米的单晶硅片上集成十几个甚至上百个电子元件。计算机开始采用中小规模的集成电路元件，这一代比上一代更小，耗电更少，功能更强，寿命更长，领域扩大，性能比上一代有很大提高。<br><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_7.jpeg" alt="小规模集成电路"></p><p>主要特点：<br>体积更小，寿命更长。<br>运行计算速度更快。<br>外围设备考试出现多样化。<br>有类似操作系统和应用程序，高级语言进一步发展。<br>应用范围扩大到企业管理和辅助设计等领域。<br>运算速度可达每秒几十万次至几百万次基本运算。在软件方面，操作系统日趋完善。</p><h2 id="第四代计算机-大规模集成电路计算机-1971年至今"><a href="#第四代计算机-大规模集成电路计算机-1971年至今" class="headerlink" title="第四代计算机 大规模集成电路计算机 (1971年至今)"></a>第四代计算机 大规模集成电路计算机 (1971年至今)</h2><p><img src="https://04imgmini.eastday.com/mobile/20190719/20190719110203_6103073e6cbe9dc0b1596a199be0b71e_8.jpeg" alt="第四代计算机"></p><p>大规模(<a href="https://dwz.cn/D8cmIGXU" target="_blank" rel="noopener">LSI</a>) 和超大规模(<a href="https://baike.baidu.com/item/VLSI" target="_blank" rel="noopener">VLSI</a>) 集成电路及微处理器为这一代计算机的典型特征<br>并行处理技术<br>计算机网络的发展与广泛应用<br>超标量技术 指在一个时钟周期内CPU可以执行一条以上的指令<br>嵌入式系统</p><h3 id="Moore-定律"><a href="#Moore-定律" class="headerlink" title="Moore 定律"></a><a href="https://dwz.cn/3zCsx372" target="_blank" rel="noopener">Moore</a> 定律</h3><p><img src="https://bkimg.cdn.bcebos.com/pic/d8f9d72a6059252da8a5e155389b033b5bb5b935?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="戈登·摩尔"></p><p>摩尔定律是由英特尔（Intel）创始人之一<a href="https://baike.baidu.com/item/%E6%88%88%E7%99%BB%C2%B7%E6%91%A9%E5%B0%94" target="_blank" rel="noopener">戈登·摩尔</a>（Gordon Moore）提出来的。其内容为：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。<br>尽管这种趋势已经持续了超过半个世纪，摩尔定律仍应该被认为是观测或推测，而不是一个物理或自然法。预计定律将持续到至少2015年或2020年 。然而，2010年国际半导体技术发展路线图的更新增长已经放缓在2013年年底，之后的时间里晶体管数量密度预计只会每三年翻一番。<br>近几年的发展越来缓慢,原因是已经达到物理极限</p><h2 id="新一代计算机"><a href="#新一代计算机" class="headerlink" title="新一代计算机"></a>新一代计算机</h2><p>新器件和非冯。诺依曼结构已成为新一代计算机的公认标志<br>神经元，生物芯片,分子电子器件,超导计算机,量子计算机<br>日本第五代计算机系统研究计划（1982年-1992年）确立并行推理将是未来信息处理的核心</p><h2 id="中国计算机"><a href="#中国计算机" class="headerlink" title="中国计算机"></a>中国计算机</h2><p>中国 一,二,三 代机的推出比世界上 一,二,三代机玩了整整一代，但这是自力更生的研制出来的<br><img src="https://bkimg.cdn.bcebos.com/pic/dbb44aed2e738bd48bc84d3bae8b87d6267ff9cb?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="银河Ⅰ号"></p><p>国防科技大学先后于1983 年和 1992 年研制成巨型机系统 银河1号和2号,运算速度都超过亿次。均配有操作系统,高级语言编译程序等系统软件<br><img src="https://bkimg.cdn.bcebos.com/pic/8b82b9014a90f603313f6af23912b31bb151edfc?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5" alt="银河Ⅱ号"></p><h3 id="中科院计算所国家智能计算机研究中心研制的曙光1000超级服务器"><a href="#中科院计算所国家智能计算机研究中心研制的曙光1000超级服务器" class="headerlink" title="中科院计算所国家智能计算机研究中心研制的曙光1000超级服务器"></a>中科院计算所国家智能计算机研究中心研制的<a href="https://dwz.cn/Enl2Ej1i" target="_blank" rel="noopener">曙光1000超级服务器</a></h3><p><img src="https://bkimg.cdn.bcebos.com/pic/7c1ed21b0ef41bd5178dc6fa51da81cb38db3de5?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="曙光-1000计算机系统"></p><p>1995 年5月,大规模<font color=red>并行处理机</font>诞生，该机峰值速度可达每秒25亿次单精度浮点运算,内存容量为1000MB,结构机间总通信容量为每秒4800MB</p><h3 id="曙光3000超级服务器"><a href="#曙光3000超级服务器" class="headerlink" title="曙光3000超级服务器"></a><a href="https://dwz.cn/v6aQ3C8E" target="_blank" rel="noopener">曙光3000超级服务器</a></h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583505213715&di=0443e9a96cb18b3d84ae8951ded878b2&imgtype=0&src=http%3A%2F%2Fimg3.donews.com%2Fuploads%2Fimg3%2Fimg_pic_1568601084_12.jpg" alt="曙光3000"></p><p>21世纪初,由70台节点计算机组成,280个处理器,峰值浮点运算速度达每秒4032亿次,内存容量160GB</p><h3 id="曙光5000超级服务器"><a href="#曙光5000超级服务器" class="headerlink" title="曙光5000超级服务器"></a><a href="https://dwz.cn/x6X3mtTh" target="_blank" rel="noopener">曙光5000超级服务器</a></h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583505320208&di=f159a5e095ceee291303395ce0c46cff&imgtype=0&src=http%3A%2F%2Fwww.jifang360.com%2Ffiles%2Fcontent%2F2014-4%2F731774001.jpg" alt="曙光5000"></p><p>2008年-08-29 我国自主研发运算<a href="https://dwz.cn/x6X3mtTh" target="_blank" rel="noopener">曙光5000超级服务器</a>能力达到 230万亿次每秒<br><font color=red>这标志着中国成为继美国之后第二个能制造和应用超百万亿次商用高性能计算机的国家</font></p><h3 id="天河一号超级计算机-国家超级计算天津中心"><a href="#天河一号超级计算机-国家超级计算天津中心" class="headerlink" title="天河一号超级计算机 国家超级计算天津中心"></a><a href="https://dwz.cn/fkCPkFPh" target="_blank" rel="noopener">天河一号超级计算机</a> 国家超级计算天津中心</h3><p><img src="http://photocdn.sohu.com/20120918/Img353404015.jpg" alt="天河一号"></p><p>2010-11-15 “天河一号”是中国首台千万亿次超级计算机<br>2010-11-14日国际TOP500组织在网站上公布了最新全球超级计算机前500强排行榜,中国首台千万亿次超级计算机系统”天河一号”雄踞世界第一</p><h3 id="天河二号超级计算机"><a href="#天河二号超级计算机" class="headerlink" title="天河二号超级计算机"></a><a href="https://dwz.cn/Q7ff5WhY" target="_blank" rel="noopener">天河二号超级计算机</a></h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583505465201&di=8da25c7d1dbcb47ff90cd76debf6f7d4&imgtype=0&src=http%3A%2F%2Fimg.takungpao.com%2F2018%2F1016%2F20181016031614609.jpg" alt="天河二号"></p><p>2013年11月<a href="https://dwz.cn/Q7ff5WhY" target="_blank" rel="noopener">天河二号超级计算机</a> 以峰值计算速度每秒5.49亿亿次、持续计算速度每秒3.39亿亿次双精度浮点运算的优异性能位居榜首</p><p>国际TOP500组织公布了全球超级计算机500强排行榜榜单,由中国国防科技大学研制的天河二号以比第二名美国的“泰坦”快近一倍的速度连续第四次获得冠军。再度轻松荣登榜首,在一年的时间内“天河二号”都是全球最快的超级计算机</p><p>2015年5月，“天河二号”上成功进行了3万亿粒子数中微子和暗物质的宇宙学N体数值模拟，揭示了宇宙大爆炸1600万年之后至今约137亿年的漫长演化进程。同时这是迄今为止世界上粒子数最多的N体数值模拟；11月16日，全球超级计算机500强榜单在美国公布，“天河二号”超级计算机以每秒33．86千万亿次连续第六度称雄。</p><h3 id="神威太光湖"><a href="#神威太光湖" class="headerlink" title="神威太光湖"></a><a href="https://dwz.cn/4L6mNGOA" target="_blank" rel="noopener">神威太光湖</a></h3><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181114/a53cee946f7945e4859f0383cde20266.jpeg" alt="神威太光湖"></p><p><a href="https://dwz.cn/4L6mNGOA" target="_blank" rel="noopener">神威·太湖之光超级计算机</a>是由国家并行计算机工程技术研究中心研制、安装在国家超级计算无锡中心的超级计算机。<br>神威·太湖之光超级计算机安装了40960个中国自主研发的“申威26010”众核处理器，该众核处理器采用64位自主申威指令系统，峰值性能为12.5亿亿次/秒，持续性能为9.3亿亿次/秒。</p><p>2016年6月，在法兰克福世界超算大会上，国际TOP500组织发布的榜单显示，“神威·太湖之光”超级计算机系统登顶榜单之首， 不仅速度比第二名“天河二号”快出近两倍，其效率也提高3倍；11月14日，在美国盐湖城公布的新一期TOP500榜单中，“神威·太湖之光”以较大的运算速度优势轻松蝉联冠军；11月18日，我国科研人员依托“神威·太湖之光”超级计算机的应用成果首次荣获“戈登·贝尔”奖，实现了我国高性能计算应用成果在该奖项上零的突破。</p><p>2017年5月，中华人民共和国科学技术部高技术中心在无锡组织了对“神威·太湖之光”计算机系统课题的现场验收。专家组经过认真考察和审核，一致同意其通过技术验收；6月19日，全球超级计算机500强榜单公布，“神威·太湖之光”以每秒9.3亿亿次的浮点运算速度第三次夺冠。</p><p>2018年11月12日，新一期全球超级计算机500强榜单在美国达拉斯发布，中国超算“神威·太湖之光”位列第三名。</p><p>2019年11月18日，全球超级计算机500强榜单发布，中国超算“神威·太湖之光”排名第三位。</p>]]></content>
      
      
      <categories>
          
          <category> 历史 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合&amp;链表&amp;队列</title>
      <link href="/2020/03/03/Collection/"/>
      <url>/2020/03/03/Collection/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList (链表)"></a>LinkedList (链表)</h2><ul><li><p><strong>链表是一种数据的存储方式，保存的数据在内存中，数据为不连续的，用指针对数据进行访问。</strong><br><strong>LinkedList是一个常用的集合类，用于顺序存储元素。</strong></p></li><li><p><strong>inkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双向队列进行操作。该类调用ListIterator实现了元素的增删改查，在LinkedList被重写。</strong></p></li></ul><p><strong>LinkedList 实现 List 接口，能对它进行队列操作。</strong></p><p><strong>LinkedList 实现 Deque 接口，即能将LinkedList当作双向队列使用。</strong></p><p><strong>LinkedList 实现了Cloneable 接口，即覆盖了函数clone()，能克隆。</strong></p><p><strong>LinkedList 实现Java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去网络传输。</strong></p><h3 id="单项列表结构"><a href="#单项列表结构" class="headerlink" title="单项列表结构"></a>单项列表结构</h3><h3 id="双向链表结构"><a href="#双向链表结构" class="headerlink" title="双向链表结构"></a>双向链表结构</h3><ul><li><strong>单向链表遍历数据只能从头到尾顺序遍历。单向列表值有“数据+后序指针“，而双向列表“前序指针+数据+后序指针”，这样结构更加灵活，同时可以从后面往前遍历。</strong></li></ul><h2 id="队列-Queue-先进先出"><a href="#队列-Queue-先进先出" class="headerlink" title="队列-Queue-(先进先出)"></a>队列-Queue-(先进先出)</h2><blockquote><ul><li><strong>什么是队列？</strong></li></ul></blockquote><ul><li><p><strong>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。其特性为先进先出（first in first out）</strong></p></li><li><p><strong>队列是经典的数据结构之一，可以保存一组元素但是存取元素必须遵守先进先出的原则</strong></p></li><li><p><strong>java.util.Queue 接口时队列的接口，规定了队列出入队的相关方法，其继承自Collection</strong></p><blockquote><ul><li><strong>常用方法</strong></li></ul></blockquote><blockquote><ul><li><strong>数组和链表的区别</strong></li></ul></blockquote><ul><li><strong>List是一个接口，它有两个常用的子类，ArrayList和LinkedList，看名字就可以看得出一种是基于数组实现另一个是基于链表实现的。</strong></li><li><strong>数组ArrayList遍历快，因为存储空间连续；链表LinkedList遍历慢，因为存储空间不连续，要去通过指针定位下一个元素，所以链表遍历慢。</strong></li><li><strong>数组插入元素和删除元素需要重新申请内存，然后将拼接结果保存进去，成本很高。例如有100个值，中间插入一个元素，需要数组重新拷贝。而这个动作对链表来说，太轻松了，改变一下相邻两个元素的指针即可。所以链表的插入和修改元素时性能非常高</strong></li><li><strong>实际开发就根据它们各自不同的特点来匹配对应业务的特点。业务一次赋值，不会改变，顺序遍历，就采用数组；业务频繁变化，有新增，有删除，则链表更加适合。</strong></li></ul><hr><pre><code class="java">public class QueueDemo {public static void main(String[] args) {    Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();    /*     * offer : 入队操作     */    queue.offer(&quot;one&quot;);    queue.offer(&quot;two&quot;);    queue.offer(&quot;three&quot;);    System.out.println(queue);    /*     * poll: 出队操作     * 获取队首元素的同时该元素是从队列删除     */    String str = queue.poll();    System.out.println(str);    System.out.println(queue);    /*     *peek :引用队首元素     *获取队首元素，但是该元素不会被删除      */    str=queue.peek();    System.out.println(str);    System.out.println(queue);    /*     * 使用迭代器遍历队列元素时，元素不做出队操作     */    for(String s:queue) {        System.out.println(s);    }    System.out.println(queue);    //Collection 定义的方法都可以使用    int size = queue.size();    System.out.println(size);    System.out.println(&quot;==========&quot;);    Queue&lt;String&gt; queue1 = new LinkedList&lt;String&gt;();    //使用poll 方法遍历队列元素    for (int i = queue.size(); i &gt;0; i--) {        String str1=queue.poll();        queue1.offer(str1);    }    System.out.println(queue1);}}</code></pre><h3 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque-双端队列"></a>Deque-双端队列</h3><blockquote><ul><li><strong>java.util.Deque  双端队列</strong></li></ul></blockquote></li></ul><ul><li><p><strong>Deque 接口继承自Queue, 是两端都可以做进出队的队列， 常用实现类： LinkedList</strong></p><pre><code class="java">public class DequeDemo { public static void main(String[] args) {     Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();     deque.offer(&quot;one&quot;);     deque.offer(&quot;two&quot;);     deque.offer(&quot;three&quot;);     deque.offer(&quot;four&quot;);     System.out.println(deque);     //从队首入队     deque.offerFirst(&quot;five&quot;);     System.out.println(deque);     //从队尾入队(等同offer)     deque.offerLast(&quot;six&quot;);     System.out.println(deque);     String str = deque.poll();     System.out.println(str);     System.out.println(deque);     str = deque.pollFirst();     System.out.println(str);     System.out.println(deque);     str = deque.pollLast();     System.out.println(str);     System.out.println(deque);     //引用队首和队尾元素     deque.peekFirst();     System.out.println(deque);     deque.peekLast();     System.out.println(deque);             }}</code></pre><h3 id="栈结构-Deque-stack-（先进后出）"><a href="#栈结构-Deque-stack-（先进后出）" class="headerlink" title="栈结构-Deque-stack-（先进后出）"></a>栈结构-Deque-stack-（先进后出）</h3><ul><li><strong>概念</strong></li><li><em>java中stack类继承于vector，其特性为后进先出(last in first out)。入栈存储数据，出栈就是拿走数据。入栈也称为压栈，出栈也称为弹栈*</em>。</li></ul></li></ul><ul><li><strong>栈可以保存一组元素,但是存取元素必须遵守先进后出的原则<br>栈 结构一般是用来实现”后退“这类功能使用的</strong></li></ul><pre><code class="java">public class StackDemo {    public static void main(String[] args) {        Deque&lt;String &gt; stack = new LinkedList&lt;String&gt;();        //创建双端链表        stack.push(&quot;one&quot;);        stack.push(&quot;two&quot;);        stack.push(&quot;three&quot;);        stack.push(&quot;four&quot;);        System.out.println(stack);        String str = stack.pop();        System.out.println(str);        System.out.println(stack);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Everybody!</title>
      <link href="/2020/03/01/Helloworld/"/>
      <url>/2020/03/01/Helloworld/</url>
      
        <content type="html"><![CDATA[<h1>大家好!这里姑苏的个人博客 ( •̀ ω •́ )✧ </h1><font size=5>很高兴~你能进入我的个人博客<p>我是一个 (Java) 初学者<br>我将这里会发布一些我平时敲代码的想法,笔记 (遇到不对的地方希望各位 <b>大牛</b> 给予指正)<br>一些常用的软件 And 一些软件或者网站/网页的教程 等等….<br>我的兴趣和爱好 (hobbies and interests)<br>平时喜欢捣鼓电脑,这也是我喜欢电脑的原因吧!<br>玩游戏,平时主要玩Switch &amp; Ps4 还有<a href="https://lol.qq.com" target="_blank" rel="noopener">英雄联盟</a>,OW 之类的吧<br>最主要的–&gt;–&gt;–&gt; <b>吃</b>___(～o￣3￣)～<br>但是不能接受辣的东西!!! (￣y▽￣)╭ Ohohoho…..</p><p>我的一些联系方式 Hi~ o(<em>￣▽￣</em>)ブ<br>QQ: <a target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=36517658&site=qq&menu=yes">36517658</a><br>WeChat: zhang36517658<br>Bilibili: <a href="驚鴻丶一線">驚鴻丶一線</a><br>Twitter: <a href="https://twitter.com/Thousand_lslad" target="_blank" rel="noopener">Thousand_lslad</a><br>Github: <a href="https://github.com/Gsiiiii" target="_blank" rel="noopener">Gsiiiii</a> (姑苏)</font><br><img src="/img/Text_Bg_img/Link_Offcial.png" alt="塞尔达"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2020/03/01/ObjectOrientedProgramming/"/>
      <url>/2020/03/01/ObjectOrientedProgramming/</url>
      
        <content type="html"><![CDATA[<h1>面向对象</h1><ul><li><p>什么是面向对象—(一种编程思想)</p><ul><li>面向对象就是把整个需求按照 特点,功能 划分,将这些存在共性的部分封装成对象,创建了对象不是为了完成某一个步骤,而是描述某个事物在解决问题的步骤中的行为</li></ul></li><li><p>面向对象有哪些优点? &amp; 缺点?</p><ul><li>优点: 易维护,易复用,易扩展<ul><li>由于面向对象有封装,继承,多态的特性,可以让你设计出低耦合的程序和系统,使其更加灵活.更加易于维护</li></ul></li><li>缺点: 性能比面向过程编程低</li></ul></li><li><p>面向对象有哪些特征?</p><ul><li><b>封装</b><ul><li>将不需要对外提供的内容隐藏起来,并提供公共的方法对其访问/调用<ul><li>好处: 提高了代码的复用性和安全性</li></ul></li></ul></li><li><b>继承</b><ul><li>通过extend关键字 可以使用现有类的所有功能,并在无需重新编写原有类的情况下对这些功能进行扩展</li></ul></li><li><b>多态</b><ul><li>字面意思来说就是多种状态/形态 </li><li>它是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作</li><li>我的理解: 同一个行为具有多个不同表现形式或形态的能力就是多态 <ul><li>关于多态每个人对其理解不同 ()</li></ul></li></ul></li></ul></li></ul><hr><ul><li><b>重载(overload) 和重写(override)</b><ul><li>重载<ul><li>发生在父子类中,方法名相同,参数列表(顺序,个数,类型)不同,方法体不同就是重载</li></ul></li><li>重写<ul><li>字面意思就是重新对其内容进行重新编写</li><li>方法名相同,参数列表相同,返回值类型相同,其子类对父类本身方法进行重新编写,就是重写<ul><li>ps: 子类的访问修饰符不得小于父类 (如果父类使用public 那么子类必须使用public)</li></ul></li></ul></li><li>重载（Overload）和重写（Override）的区别？<ul><li>方法的重载和重写都是实现多态的方式</li><li>区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li><li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</li><li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</li><li>重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</li></ul></li></ul></li></ul><hr><ul><li>static (静态)<ul><li>静态变量:<ul><li>它是属于<b>类</b>的,存储在方法区中,只有一份</li><li>常通过 <b>类名.</b> 来访问</li><li>何时用?<ul><li>所有对象所共享的数据(图片,音频,视频等)</li></ul></li></ul></li><li>静态方法:<ul><li>他也是属于类的,存储在方法区中,只有一份</li><li>常常通过 <b>类名.</b>来访问</li><li>静态方法中没有隐式的 <b>this.</b> 的传递</li><li>静态方法中不能直接访问实例成员</li><li>何时用?<ul><li>方法的操作仅与参与相关而与对象无关</li></ul></li></ul></li><li>静态块: <ul><li>属于类,在类被加载时自动执行,只执行一次</li><li>何时用?<ul><li>加载/初始化静态资源时 (图片,视频,音频)</li></ul></li></ul></li></ul></li></ul><hr><ul><li><p>接口 (interface)</p><ul><li>是一种数据类型(引用类型类型)</li><li>由 interface 定义</li><li>只能包含常量和抽象方法</li><li>接口是不能实例化</li><li>接口是需要被 实现/继承 ,实现/派生类 : 必须重写接口中的所有抽象方法</li><li>一个类可以实现多个接口,用逗号分隔 若有继承又实现时,必须像继承后是实现</li><li>接口可以继承接口</li></ul></li><li><p>抽象 (abstract)</p><ul><li>由 abstract 修饰</li><li>包含抽象方法的类型必须时抽象类,不包含抽象方的类也可以声明抽象类–(看你心情)</li><li>抽象类不能实例化</li><li>抽象类是需要被继承,派生类<ul><li>重写其所有的抽象方法</li><li>也声明为抽象类–(一般是不会用的)</li></ul></li><li>抽象类的意义:<ul><li>封装派生类的共有的属性和行为–(代码复用)</li><li>为所有派生类提供统一的类型  –(向上造型)</li><li>可以包含抽象方法,为所有派生类提供统一的入口 <ul><li>派生类的具体实现不同,但入口是一致的</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot</title>
      <link href="/2020/03/01/Spring%20Boot/"/>
      <url>/2020/03/01/Spring%20Boot/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot基础"><a href="#SpringBoot基础" class="headerlink" title="SpringBoot基础"></a>SpringBoot基础</h2><h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><ol><li>能够理解Spring的优缺点</li><li>能够理解SpringBoot的特点</li><li>能够理解SpringBoot的核心功能</li><li>能够搭建SpringBoot的环境</li><li>能够完成application.properties配置文件的配置</li><li>能够完成application.yml配置文件的配置</li><li>能够使用SpringBoot集成Mybatis</li><li>能够使用SpringBoot集成Junit</li><li>能够使用SpringBoot集成SpringData JPA</li></ol><h1 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h1><h2 id="1-1-原有Spring优缺点分析"><a href="#1-1-原有Spring优缺点分析" class="headerlink" title="1.1  原有Spring优缺点分析"></a>1.1  原有Spring优缺点分析</h2><h3 id="1-1-1-Spring的优点分析"><a href="#1-1-1-Spring的优点分析" class="headerlink" title="1.1.1 Spring的优点分析"></a>1.1.1 Spring的优点分析</h3><p>Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。</p><h3 id="1-1-2-Spring的缺点分析"><a href="#1-1-2-Spring的缺点分析" class="headerlink" title="1.1.2 Spring的缺点分析"></a>1.1.2 Spring的缺点分析</h3><p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p><p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p><p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p><h2 id="1-2-SpringBoot的概述"><a href="#1-2-SpringBoot的概述" class="headerlink" title="1.2 SpringBoot的概述"></a>1.2 SpringBoot的概述</h2><h3 id="1-2-1-SpringBoot解决上述Spring的缺点"><a href="#1-2-1-SpringBoot解决上述Spring的缺点" class="headerlink" title="1.2.1 SpringBoot解决上述Spring的缺点"></a>1.2.1 SpringBoot解决上述Spring的缺点</h3><p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p><h3 id="1-2-2-SpringBoot的特点"><a href="#1-2-2-SpringBoot的特点" class="headerlink" title="1.2.2 SpringBoot的特点"></a>1.2.2 SpringBoot的特点</h3><ul><li>为基于Spring的开发提供更快的入门体验</li><li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li><li>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li></ul><h3 id="1-2-3-SpringBoot的核心功能"><a href="#1-2-3-SpringBoot的核心功能" class="headerlink" title="1.2.3 SpringBoot的核心功能"></a>1.2.3 SpringBoot的核心功能</h3><ul><li><p>起步依赖</p><p>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</p><p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p></li><li><p>自动配置</p><p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p></li></ul><p>​    注意：起步依赖和自动配置的原理剖析会在第三章《SpringBoot原理分析》进行详细讲解</p><h1 id="二、SpringBoot快速入门"><a href="#二、SpringBoot快速入门" class="headerlink" title="二、SpringBoot快速入门"></a>二、SpringBoot快速入门</h1><h2 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h2><h3 id="2-1-1-创建Maven工程"><a href="#2-1-1-创建Maven工程" class="headerlink" title="2.1.1 创建Maven工程"></a>2.1.1 创建Maven工程</h3><p>使用idea工具创建一个maven工程，该工程为普通的java工程即可</p><p><img src="/img/SpringBoot/1.png" alt="1"></p><p><img src="/img/SpringBoot/2.png" alt="2"></p><p><img src="/img/SpringBoot/3.png" alt="3"></p><p><img src="/img/SpringBoot/4.png" alt="4"></p><h3 id="2-1-2-添加SpringBoot的起步依赖"><a href="#2-1-2-添加SpringBoot的起步依赖" class="headerlink" title="2.1.2 添加SpringBoot的起步依赖"></a>2.1.2 添加SpringBoot的起步依赖</h3><p>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p><pre><code class="xml">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;</code></pre><p>SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h3 id="2-1-3-编写SpringBoot引导类"><a href="#2-1-3-编写SpringBoot引导类" class="headerlink" title="2.1.3 编写SpringBoot引导类"></a>2.1.3 编写SpringBoot引导类</h3><p>要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问</p><pre><code class="java">package com.itheima;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MySpringBootApplication {    public static void main(String[] args) {        SpringApplication.run(MySpringBootApplication.class);    }}</code></pre><h3 id="2-1-4-编写Controller"><a href="#2-1-4-编写Controller" class="headerlink" title="2.1.4 编写Controller"></a>2.1.4 编写Controller</h3><p>在引导类MySpringBootApplication同级包或者子级包中创建QuickStartController</p><pre><code class="java">package com.itheima.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class QuickStartController {    @RequestMapping(&quot;/quick&quot;)    @ResponseBody    public String quick(){        return &quot;springboot 访问成功!&quot;;    }}</code></pre><h3 id="2-1-5-测试"><a href="#2-1-5-测试" class="headerlink" title="2.1.5 测试"></a>2.1.5 测试</h3><p>执行SpringBoot起步类的主方法，控制台打印日志如下：</p><pre><code>.   ____          _            __ _ _ /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#39;  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v2.0.1.RELEASE)2018-05-08 14:29:59.714  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Starting MySpringBootApplication on DESKTOP-RRUNFUH with PID 5672 (C:\Users\muzimoo\IdeaProjects\IdeaTest\springboot_quick\target\classes started by muzimoo in C:\Users\muzimoo\IdeaProjects\IdeaTest)... ... ...o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2018-05-08 14:30:03.126  INFO 5672 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2018-05-08 14:30:03.196  INFO 5672 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#39;&#39;2018-05-08 14:30:03.206  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Started MySpringBootApplication in 4.252 seconds (JVM running for 5.583)</code></pre><p>通过日志发现，Tomcat started on port(s): 8080 (http) with context path ‘’</p><p>tomcat已经起步，端口监听8080，web应用的虚拟工程名称为空</p><p>打开浏览器访问url地址为：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a></p><p><img src="/img/SpringBoot/5.png" alt="5"></p><h2 id="2-2-快速入门解析"><a href="#2-2-快速入门解析" class="headerlink" title="2.2 快速入门解析"></a>2.2 快速入门解析</h2><h3 id="2-2-2-SpringBoot代码解析"><a href="#2-2-2-SpringBoot代码解析" class="headerlink" title="2.2.2 SpringBoot代码解析"></a>2.2.2 SpringBoot代码解析</h3><ul><li>@SpringBootApplication：标注SpringBoot的启动类，该注解具备多种功能（后面详细剖析）</li><li>SpringApplication.run(MySpringBootApplication.class) 代表运行SpringBoot的启动类，参数为SpringBoot启动类的字节码对象</li></ul><h3 id="2-2-3-SpringBoot工程热部署"><a href="#2-2-3-SpringBoot工程热部署" class="headerlink" title="2.2.3 SpringBoot工程热部署"></a>2.2.3 SpringBoot工程热部署</h3><p>我们在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间，我们可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，我们称之为热部署。</p><pre><code class="xml">&lt;!--热部署配置--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>注意：IDEA进行SpringBoot热部署失败原因</p><p>出现这种情况，并不是热部署配置问题，其根本原因是因为Intellij IEDA默认情况下不会自动编译，需要对IDEA进行自动编译的设置，如下：</p><p><img src="/img/SpringBoot/19.png" alt="19"></p><p>然后 Shift+Ctrl+Alt+/，选择Registry</p><p><img src="/img/SpringBoot/20.png" alt="20"></p><h3 id="2-2-4-使用idea快速创建SpringBoot项目"><a href="#2-2-4-使用idea快速创建SpringBoot项目" class="headerlink" title="2.2.4 使用idea快速创建SpringBoot项目"></a>2.2.4 使用idea快速创建SpringBoot项目</h3><p><img src="/img/SpringBoot/6.png" alt="6"></p><p><img src="/img/SpringBoot/7.png" alt="7"></p><p><img src="/img/SpringBoot/8.png" alt="8"></p><p><img src="/img/SpringBoot/9.png" alt="9"></p><p><img src="/img/SpringBoot/10.png" alt="10"></p><p>通过idea快速创建的SpringBoot项目的pom.xml中已经导入了我们选择的web的起步依赖的坐标</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;springboot_quick2&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;springboot_quick2&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;9&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>可以使用快速入门的方式创建Controller进行访问，此处不再赘述</p><h1 id="三、SpringBoot原理分析"><a href="#三、SpringBoot原理分析" class="headerlink" title="三、SpringBoot原理分析"></a>三、SpringBoot原理分析</h1><h2 id="3-1-起步依赖原理分析"><a href="#3-1-起步依赖原理分析" class="headerlink" title="3.1 起步依赖原理分析"></a>3.1 起步依赖原理分析</h2><h3 id="3-1-1-分析spring-boot-starter-parent"><a href="#3-1-1-分析spring-boot-starter-parent" class="headerlink" title="3.1.1 分析spring-boot-starter-parent"></a>3.1.1 分析spring-boot-starter-parent</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre><code class="xml">&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;  &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;  &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;</code></pre><p>按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre><code class="xml">&lt;properties&gt;      &lt;activemq.version&gt;5.15.3&lt;/activemq.version&gt;      &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;      &lt;appengine-sdk.version&gt;1.9.63&lt;/appengine-sdk.version&gt;      &lt;artemis.version&gt;2.4.0&lt;/artemis.version&gt;      &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt;      &lt;assertj.version&gt;3.9.1&lt;/assertj.version&gt;      &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;      &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt;      &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt;      &lt;byte-buddy.version&gt;1.7.11&lt;/byte-buddy.version&gt;      ... ... ...&lt;/properties&gt;&lt;dependencyManagement&gt;      &lt;dependencies&gt;          &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;          &lt;/dependency&gt;          &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt;            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;          &lt;/dependency&gt;          ... ... ...    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt;      &lt;pluginManagement&gt;        &lt;plugins&gt;              &lt;plugin&gt;                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;                &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;${kotlin.version}&lt;/version&gt;              &lt;/plugin&gt;              &lt;plugin&gt;                &lt;groupId&gt;org.jooq&lt;/groupId&gt;                &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;                &lt;version&gt;${jooq.version}&lt;/version&gt;              &lt;/plugin&gt;              &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;              &lt;/plugin&gt;              ... ... ...        &lt;/plugins&gt;      &lt;/pluginManagement&gt;&lt;/build&gt;</code></pre><p>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p><h3 id="3-1-2-分析spring-boot-starter-web"><a href="#3-1-2-分析spring-boot-starter-web" class="headerlink" title="3.1.2 分析spring-boot-starter-web"></a>3.1.2 分析spring-boot-starter-web</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-web，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;      &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starters&lt;/artifactId&gt;        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;      &lt;/parent&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;      &lt;name&gt;Spring Boot Web Starter&lt;/name&gt;      &lt;dependencies&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;              &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;              &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;              &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;              &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;              &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;              &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;              &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;              &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;              &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;              &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;              &lt;version&gt;6.0.9.Final&lt;/version&gt;              &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-web&lt;/artifactId&gt;              &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;              &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;              &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;              &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;      &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。</p><h2 id="3-2-自动配置原理解析"><a href="#3-2-自动配置原理解析" class="headerlink" title="3.2 自动配置原理解析"></a>3.2 自动配置原理解析</h2><p>按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication</p><pre><code class="java">@SpringBootApplicationpublic class MySpringBootApplication {    public static void main(String[] args) {        SpringApplication.run(MySpringBootApplication.class);    }}</code></pre><p>注解@SpringBootApplication的源码</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {    /**     * Exclude specific auto-configuration classes such that they will never be applied.     * @return the classes to exclude     */    @AliasFor(annotation = EnableAutoConfiguration.class)    Class&lt;?&gt;[] exclude() default {};    ... ... ...}</code></pre><p>其中，</p><p>@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类</p><p>@EnableAutoConfiguration：SpringBoot自动配置功能开启</p><p>按住Ctrl点击查看注解@EnableAutoConfiguration</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {    ... ... ...}</code></pre><p>其中，@Import(AutoConfigurationImportSelector.class) 导入了AutoConfigurationImportSelector类</p><p>按住Ctrl点击查看AutoConfigurationImportSelector源码</p><pre><code class="java">public String[] selectImports(AnnotationMetadata annotationMetadata) {        ... ... ...        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,                                                                   attributes);        configurations = removeDuplicates(configurations);        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);        checkExcludedClasses(configurations, exclusions);        configurations.removeAll(exclusions);        configurations = filter(configurations, autoConfigurationMetadata);        fireAutoConfigurationImportEvents(configurations, exclusions);        return StringUtils.toStringArray(configurations);}protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,            AnnotationAttributes attributes) {        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());        return configurations;}</code></pre><p>其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表 </p><p><img src="/img/SpringBoot/11.png" alt="11"></p><p>spring.factories 文件中有关自动配置的配置信息如下：</p><pre><code>... ... ...org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\... ... ...</code></pre><p>上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而SpringApplication在获取这些类名后再加载</p><p>我们以ServletWebServerFactoryAutoConfiguration为例来分析源码：</p><pre><code class="java">@Configuration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,        ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,        ServletWebServerFactoryConfiguration.EmbeddedJetty.class,        ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })public class ServletWebServerFactoryAutoConfiguration {    ... ... ...}</code></pre><p>其中，</p><p>@EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类</p><p>进入ServerProperties.class源码如下：</p><pre><code class="java">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)public class ServerProperties {    /**     * Server HTTP port.     */    private Integer port;    /**     * Network address to which the server should bind.     */    private InetAddress address;      ... ... ...}</code></pre><p>其中，</p><p>prefix = “server” 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下：</p><p><img src="/img/SpringBoot/12.png" alt="12"></p><h1 id="四、SpringBoot的配置文件"><a href="#四、SpringBoot的配置文件" class="headerlink" title="四、SpringBoot的配置文件"></a>四、SpringBoot的配置文件</h1><h2 id="4-1-SpringBoot配置文件类型"><a href="#4-1-SpringBoot配置文件类型" class="headerlink" title="4.1 SpringBoot配置文件类型"></a>4.1 SpringBoot配置文件类型</h2><h3 id="4-1-1-SpringBoot配置文件类型和作用"><a href="#4-1-1-SpringBoot配置文件类型和作用" class="headerlink" title="4.1.1 SpringBoot配置文件类型和作用"></a>4.1.1 SpringBoot配置文件类型和作用</h3><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。</p><p>SpringBoot默认会从Resources目录下加载application.properties或application.yml（application.yaml）文件</p><p>其中，application.properties文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。</p><h3 id="4-1-2-application-yml配置文件"><a href="#4-1-2-application-yml配置文件" class="headerlink" title="4.1.2 application.yml配置文件"></a>4.1.2 application.yml配置文件</h3><h4 id="4-1-2-1-yml配置文件简介"><a href="#4-1-2-1-yml配置文件简介" class="headerlink" title="4.1.2.1 yml配置文件简介"></a>4.1.2.1 yml配置文件简介</h4><p>YML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p><p>YML文件的扩展名可以使用.yml或者.yaml。</p><h4 id="4-1-2-2-yml配置文件的语法"><a href="#4-1-2-2-yml配置文件的语法" class="headerlink" title="4.1.2.2 yml配置文件的语法"></a>4.1.2.2 yml配置文件的语法</h4><h5 id="4-1-2-2-1-配置普通数据"><a href="#4-1-2-2-1-配置普通数据" class="headerlink" title="4.1.2.2.1 配置普通数据"></a>4.1.2.2.1 配置普通数据</h5><ul><li><p>语法： key: value</p></li><li><p>示例代码：</p></li><li><pre><code class="yaml">name: haohao</code></pre></li><li><p>注意：value之前有一个空格</p></li></ul><h5 id="4-1-2-2-2-配置对象数据"><a href="#4-1-2-2-2-配置对象数据" class="headerlink" title="4.1.2.2.2 配置对象数据"></a>4.1.2.2.2 配置对象数据</h5><ul><li><p>语法： </p><p>​    key: </p><p>​        key1: value1</p><p>​        key2: value2</p><p>​    或者：</p><p>​    key: {key1: value1,key2: value2}</p></li><li><p>示例代码：</p></li><li><pre><code class="yaml">person:  name: haohao  age: 31  addr: beijing#或者person: {name: haohao,age: 31,addr: beijing}</code></pre></li><li><p>注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别</p></li></ul><h5 id="4-1-2-2-2-配置Map数据"><a href="#4-1-2-2-2-配置Map数据" class="headerlink" title="4.1.2.2.2 配置Map数据"></a>4.1.2.2.2 配置Map数据</h5><p>同上面的对象写法</p><h5 id="4-1-2-2-3-配置数组（List、Set）数据"><a href="#4-1-2-2-3-配置数组（List、Set）数据" class="headerlink" title="4.1.2.2.3 配置数组（List、Set）数据"></a>4.1.2.2.3 配置数组（List、Set）数据</h5><ul><li><p>语法： </p><p>​    key: </p><p>​        - value1</p><p>​        - value2</p><p>或者：</p><p>​    key: [value1,value2]</p></li><li><p>示例代码：</p></li><li><pre><code class="yaml">city:  - beijing  - tianjin  - shanghai  - chongqing#或者city: [beijing,tianjin,shanghai,chongqing]#集合中的元素是对象形式student:  - name: zhangsan    age: 18    score: 100  - name: lisi    age: 28    score: 88  - name: wangwu    age: 38    score: 90</code></pre></li><li><p>注意：value1与之间的 - 之间存在一个空格</p></li></ul><h3 id="4-1-3-SpringBoot配置信息的查询"><a href="#4-1-3-SpringBoot配置信息的查询" class="headerlink" title="4.1.3 SpringBoot配置信息的查询"></a>4.1.3 SpringBoot配置信息的查询</h3><p>上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档</p><p>文档URL：<a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties</a></p><p>常用的配置摘抄如下：</p><pre><code class="properties"># QUARTZ SCHEDULER (QuartzProperties)spring.quartz.jdbc.initialize-schema=embedded # Database schema initialization mode.spring.quartz.jdbc.schema=classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.spring.quartz.job-store-type=memory # Quartz job store type.spring.quartz.properties.*= # Additional Quartz Scheduler properties.# ----------------------------------------# WEB PROPERTIES# ----------------------------------------# EMBEDDED SERVER CONFIGURATION (ServerProperties)server.port=8080 # Server HTTP port.server.servlet.context-path= # Context path of the application.server.servlet.path=/ # Path of the main dispatcher servlet.# HTTP encoding (HttpEncodingProperties)spring.http.encoding.charset=UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.# JACKSON (JacksonProperties)spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.# SPRING MVC (WebMvcProperties)spring.mvc.servlet.load-on-startup=-1 # Load on startup priority of the dispatcher servlet.spring.mvc.static-path-pattern=/** # Path pattern used for static resources.spring.mvc.view.prefix= # Spring MVC view prefix.spring.mvc.view.suffix= # Spring MVC view suffix.# DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)spring.datasource.driver-class-name= # Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.spring.datasource.password= # Login password of the database.spring.datasource.url= # JDBC URL of the database.spring.datasource.username= # Login username of the database.# JEST (Elasticsearch HTTP client) (JestProperties)spring.elasticsearch.jest.password= # Login password.spring.elasticsearch.jest.proxy.host= # Proxy host the HTTP client should use.spring.elasticsearch.jest.proxy.port= # Proxy port the HTTP client should use.spring.elasticsearch.jest.read-timeout=3s # Read timeout.spring.elasticsearch.jest.username= # Login username.</code></pre><p>我们可以通过配置application.poperties 或者 application.yml 来修改SpringBoot的默认配置</p><p>例如：</p><p>application.properties文件</p><pre><code class="properties">server.port=8888server.servlet.context-path=demo</code></pre><p>application.yml文件</p><pre><code class="yaml">server:  port: 8888  servlet:    context-path: /demo</code></pre><h2 id="4-2-配置文件与配置类的属性映射方式"><a href="#4-2-配置文件与配置类的属性映射方式" class="headerlink" title="4.2 配置文件与配置类的属性映射方式"></a>4.2 配置文件与配置类的属性映射方式</h2><h3 id="4-2-1-使用注解-Value映射"><a href="#4-2-1-使用注解-Value映射" class="headerlink" title="4.2.1 使用注解@Value映射"></a>4.2.1 使用注解@Value映射</h3><p>我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上</p><p>例如：</p><p>application.properties配置如下：</p><pre><code class="properties">person:  name: zhangsan  age: 18</code></pre><p>或者，application.yml配置如下：</p><pre><code class="yaml">person:  name: zhangsan  age: 18</code></pre><p>实体Bean代码如下：</p><pre><code class="java">@Controllerpublic class QuickStartController {    @Value(&quot;${person.name}&quot;)    private String name;    @Value(&quot;${person.age}&quot;)    private Integer age;    @RequestMapping(&quot;/quick&quot;)    @ResponseBody    public String quick(){        return &quot;springboot 访问成功! name=&quot;+name+&quot;,age=&quot;+age;    }}</code></pre><p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p><p><img src="/img/SpringBoot/13.png" alt="13"></p><h3 id="4-2-2-使用注解-ConfigurationProperties映射"><a href="#4-2-2-使用注解-ConfigurationProperties映射" class="headerlink" title="4.2.2 使用注解@ConfigurationProperties映射"></a>4.2.2 使用注解@ConfigurationProperties映射</h3><p>通过注解@ConfigurationProperties(prefix=”配置文件中的key的前缀”)可以将配置文件中的配置自动与实体进行映射</p><p>application.properties配置如下：</p><pre><code class="properties">person:  name: zhangsan  age: 18</code></pre><p>或者，application.yml配置如下：</p><pre><code class="yaml">person:  name: zhangsan  age: 18</code></pre><p>实体Bean代码如下：</p><pre><code class="java">@Controller@ConfigurationProperties(prefix = &quot;person&quot;)public class QuickStartController {    private String name;    private Integer age;    @RequestMapping(&quot;/quick&quot;)    @ResponseBody    public String quick(){        return &quot;springboot 访问成功! name=&quot;+name+&quot;,age=&quot;+age;    }    public void setName(String name) {        this.name = name;    }    public void setAge(Integer age) {        this.age = age;    }}</code></pre><p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p><p><img src="/img/SpringBoot/13.png" alt="13"></p><p>注意：使用@ConfigurationProperties方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法</p><h1 id="五、SpringBoot与整合其他技术"><a href="#五、SpringBoot与整合其他技术" class="headerlink" title="五、SpringBoot与整合其他技术"></a>五、SpringBoot与整合其他技术</h1><h2 id="5-1-SpringBoot整合Mybatis"><a href="#5-1-SpringBoot整合Mybatis" class="headerlink" title="5.1 SpringBoot整合Mybatis"></a>5.1 SpringBoot整合Mybatis</h2><h3 id="5-1-1-添加Mybatis的起步依赖"><a href="#5-1-1-添加Mybatis的起步依赖" class="headerlink" title="5.1.1 添加Mybatis的起步依赖"></a>5.1.1 添加Mybatis的起步依赖</h3><pre><code class="xml">&lt;!--mybatis起步依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="5-1-2-添加数据库驱动坐标"><a href="#5-1-2-添加数据库驱动坐标" class="headerlink" title="5.1.2 添加数据库驱动坐标"></a>5.1.2 添加数据库驱动坐标</h3><pre><code class="xml">&lt;!-- MySQL连接驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="5-1-3-添加数据库连接信息"><a href="#5-1-3-添加数据库连接信息" class="headerlink" title="5.1.3 添加数据库连接信息"></a>5.1.3 添加数据库连接信息</h3><p>在application.properties中添加数据量的连接信息</p><pre><code class="properties">#DB Configuration:spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=root</code></pre><h3 id="5-1-4-创建user表"><a href="#5-1-4-创建user表" class="headerlink" title="5.1.4 创建user表"></a>5.1.4 创建user表</h3><p>在test数据库中创建user表</p><pre><code class="sql">-- ------------------------------ Table structure for `user`-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(50) DEFAULT NULL,  `password` varchar(50) DEFAULT NULL,  `name` varchar(50) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES (&#39;1&#39;, &#39;zhangsan&#39;, &#39;123&#39;, &#39;张三&#39;);INSERT INTO `user` VALUES (&#39;2&#39;, &#39;lisi&#39;, &#39;123&#39;, &#39;李四&#39;);</code></pre><h3 id="5-1-5-创建实体Bean"><a href="#5-1-5-创建实体Bean" class="headerlink" title="5.1.5 创建实体Bean"></a>5.1.5 创建实体Bean</h3><pre><code class="java">public class User {    // 主键    private Long id;    // 用户名    private String username;    // 密码    private String password;    // 姓名    private String name;    //此处省略getter和setter方法 .. ..}</code></pre><h3 id="5-1-6-编写Mapper"><a href="#5-1-6-编写Mapper" class="headerlink" title="5.1.6 编写Mapper"></a>5.1.6 编写Mapper</h3><pre><code class="java">@Mapperpublic interface UserMapper {    public List&lt;User&gt; queryUserList();}</code></pre><p>注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中</p><h3 id="5-1-7-配置Mapper映射文件"><a href="#5-1-7-配置Mapper映射文件" class="headerlink" title="5.1.7 配置Mapper映射文件"></a>5.1.7 配置Mapper映射文件</h3><p>在src\main\resources\mapper路径下加入UserMapper.xml配置文件”</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.itheima.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;queryUserList&quot; resultType=&quot;user&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="5-1-8-在application-properties中添加mybatis的信息"><a href="#5-1-8-在application-properties中添加mybatis的信息" class="headerlink" title="5.1.8 在application.properties中添加mybatis的信息"></a>5.1.8 在application.properties中添加mybatis的信息</h3><pre><code class="properties">#spring集成Mybatis环境#pojo别名扫描包mybatis.type-aliases-package=com.itheima.domain#加载Mybatis映射文件mybatis.mapper-locations=classpath:mapper/*Mapper.xml</code></pre><h3 id="5-1-9-编写测试Controller"><a href="#5-1-9-编写测试Controller" class="headerlink" title="5.1.9 编写测试Controller"></a>5.1.9 编写测试Controller</h3><pre><code class="java">@Controllerpublic class MapperController {    @Autowired    private UserMapper userMapper;    @RequestMapping(&quot;/queryUser&quot;)    @ResponseBody    public List&lt;User&gt; queryUser(){        List&lt;User&gt; users = userMapper.queryUserList();        return users;    }}</code></pre><h3 id="5-1-10-测试"><a href="#5-1-10-测试" class="headerlink" title="5.1.10 测试"></a>5.1.10 测试</h3><p><img src="/img/SpringBoot/14.png" alt="14"></p><h2 id="5-2-SpringBoot整合Junit"><a href="#5-2-SpringBoot整合Junit" class="headerlink" title="5.2 SpringBoot整合Junit"></a>5.2 SpringBoot整合Junit</h2><h3 id="5-2-1-添加Junit的起步依赖"><a href="#5-2-1-添加Junit的起步依赖" class="headerlink" title="5.2.1 添加Junit的起步依赖"></a>5.2.1 添加Junit的起步依赖</h3><pre><code class="xml">&lt;!--测试的起步依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="5-2-2-编写测试类"><a href="#5-2-2-编写测试类" class="headerlink" title="5.2.2 编写测试类"></a>5.2.2 编写测试类</h3><pre><code class="java">package com.itheima.test;import com.itheima.MySpringBootApplication;import com.itheima.domain.User;import com.itheima.mapper.UserMapper;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest(classes = MySpringBootApplication.class)public class MapperTest {    @Autowired    private UserMapper userMapper;    @Test    public void test() {        List&lt;User&gt; users = userMapper.queryUserList();        System.out.println(users);    }}</code></pre><p>其中，</p><p>SpringRunner继承自SpringJUnit4ClassRunner，使用哪一个Spring提供的测试测试引擎都可以</p><pre><code class="java">public final class SpringRunner extends SpringJUnit4ClassRunner </code></pre><p>@SpringBootTest的属性指定的是引导类的字节码对象</p><h3 id="5-2-3-控制台打印信息"><a href="#5-2-3-控制台打印信息" class="headerlink" title="5.2.3 控制台打印信息"></a>5.2.3 控制台打印信息</h3><p><img src="/img/SpringBoot/15.png" alt="15"></p><h2 id="5-3-SpringBoot整合Spring-Data-JPA"><a href="#5-3-SpringBoot整合Spring-Data-JPA" class="headerlink" title="5.3 SpringBoot整合Spring Data JPA"></a>5.3 SpringBoot整合Spring Data JPA</h2><h3 id="5-3-1-添加Spring-Data-JPA的起步依赖"><a href="#5-3-1-添加Spring-Data-JPA的起步依赖" class="headerlink" title="5.3.1 添加Spring Data JPA的起步依赖"></a>5.3.1 添加Spring Data JPA的起步依赖</h3><pre><code class="xml">&lt;!-- springBoot JPA的起步依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="5-3-2-添加数据库驱动依赖"><a href="#5-3-2-添加数据库驱动依赖" class="headerlink" title="5.3.2 添加数据库驱动依赖"></a>5.3.2 添加数据库驱动依赖</h3><pre><code class="xml">&lt;!-- MySQL连接驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="5-3-3-在application-properties中配置数据库和jpa的相关属性"><a href="#5-3-3-在application-properties中配置数据库和jpa的相关属性" class="headerlink" title="5.3.3 在application.properties中配置数据库和jpa的相关属性"></a>5.3.3 在application.properties中配置数据库和jpa的相关属性</h3><pre><code class="properties">#DB Configuration:spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=root#JPA Configuration:spring.jpa.database=MySQLspring.jpa.show-sql=truespring.jpa.generate-ddl=truespring.jpa.hibernate.ddl-auto=updatespring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy</code></pre><h3 id="5-3-4-创建实体配置实体"><a href="#5-3-4-创建实体配置实体" class="headerlink" title="5.3.4 创建实体配置实体"></a>5.3.4 创建实体配置实体</h3><pre><code class="java">@Entitypublic class User {    // 主键    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    // 用户名    private String username;    // 密码    private String password;    // 姓名    private String name;    //此处省略setter和getter方法... ...}</code></pre><h3 id="5-3-5-编写UserRepository"><a href="#5-3-5-编写UserRepository" class="headerlink" title="5.3.5 编写UserRepository"></a>5.3.5 编写UserRepository</h3><pre><code class="java">public interface UserRepository extends JpaRepository&lt;User,Long&gt;{    public List&lt;User&gt; findAll();}</code></pre><h3 id="5-3-6-编写测试类"><a href="#5-3-6-编写测试类" class="headerlink" title="5.3.6 编写测试类"></a>5.3.6 编写测试类</h3><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTest(classes=MySpringBootApplication.class)public class JpaTest {    @Autowired    private UserRepository userRepository;    @Test    public void test(){        List&lt;User&gt; users = userRepository.findAll();        System.out.println(users);    }}</code></pre><h3 id="5-3-7-控制台打印信息"><a href="#5-3-7-控制台打印信息" class="headerlink" title="5.3.7 控制台打印信息"></a>5.3.7 控制台打印信息</h3><p><img src="/img/SpringBoot/16.png" alt="16"></p><p>注意：如果是jdk9，执行报错如下：</p><p><img src="/img/SpringBoot/17.png" alt="17"></p><p>原因：jdk缺少相应的jar</p><p>解决方案：手动导入对应的maven坐标，如下：</p><pre><code class="xml">&lt;!--jdk9需要导入如下坐标--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="5-4-SpringBoot整合Redis"><a href="#5-4-SpringBoot整合Redis" class="headerlink" title="5.4 SpringBoot整合Redis"></a>5.4 SpringBoot整合Redis</h2><h3 id="5-4-1-添加redis的起步依赖"><a href="#5-4-1-添加redis的起步依赖" class="headerlink" title="5.4.1 添加redis的起步依赖"></a>5.4.1 添加redis的起步依赖</h3><pre><code class="xml">&lt;!-- 配置使用redis启动器 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="5-4-2-配置redis的连接信息"><a href="#5-4-2-配置redis的连接信息" class="headerlink" title="5.4.2 配置redis的连接信息"></a>5.4.2 配置redis的连接信息</h3><pre><code class="properties">#Redisspring.redis.host=127.0.0.1spring.redis.port=6379</code></pre><h3 id="5-4-3-注入RedisTemplate测试redis操作"><a href="#5-4-3-注入RedisTemplate测试redis操作" class="headerlink" title="5.4.3 注入RedisTemplate测试redis操作"></a>5.4.3 注入RedisTemplate测试redis操作</h3><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTest(classes = SpringbootJpaApplication.class)public class RedisTest {    @Autowired    private UserRepository userRepository;    @Autowired    private RedisTemplate&lt;String, String&gt; redisTemplate;    @Test    public void test() throws JsonProcessingException {        //从redis缓存中获得指定的数据        String userListData = redisTemplate.boundValueOps(&quot;user.findAll&quot;).get();        //如果redis中没有数据的话        if(null==userListData){            //查询数据库获得数据            List&lt;User&gt; all = userRepository.findAll();            //转换成json格式字符串            ObjectMapper om = new ObjectMapper();            userListData = om.writeValueAsString(all);            //将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库            redisTemplate.boundValueOps(&quot;user.findAll&quot;).set(userListData);            System.out.println(&quot;===============从数据库获得数据===============&quot;);        }else{            System.out.println(&quot;===============从redis缓存中获得数据===============&quot;);        }        System.out.println(userListData);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
